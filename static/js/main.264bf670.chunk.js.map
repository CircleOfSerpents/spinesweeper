{"version":3,"sources":["engine/Cell.ts","GameCell/GameCell.tsx","GameBoard/GameBoard.tsx","engine/GameState.ts","engine/Board.ts","engine/Game.ts","GameTimer/GameTimer.tsx","App.tsx","reportWebVitals.js","index.js"],"names":["CellState","Unclicked","Clicked","Flagged","Questioned","mineStates","UnclickedMine","ClickedMine","FlaggedMine","QuestionedMine","unclickedStates","flaggedStates","unclickedNonMineStates","Cell","_isClicked","_isMine","_isFlagged","_isQuestioned","this","isMine","GameCell","cellState","numNeighborMines","className","includes","String","GameBoard","GameState","gameBoard","onCellClick","id","board","map","row","rowNumber","cell","columnNumber","onClick","e","column","onContextMenu","getCellState","getCellNumNeighborMines","neighborOffsets","Board","rows","columns","mines","mineCount","validateInputs","createInternalBoard","addMines","cellIndex","floodfill","explode","isFullyFlaggedCell","clickAllNeighbors","calculateMineCount","gameState","calculateGameState","cleanUpGameIfNecessary","getCell","rightClick","stateCounts","getStateCounts","Lost","Won","Active","count","getInBoundNeighbors","forEach","neighbor","isCellInBounds","isMineCell","filter","Boolean","length","isFlaggedCell","Error","click","inBoundsNeighbors","offset","push","Array","numMines","maxMines","addedMines","getRandomInt","isUnclickedNonMineCell","getCellNumNeighborFlags","max","Math","floor","random","arr","concat","Game","_gameState","Idle","_","cloneDeep","useState","timer","setTimer","increment","clear","savedIncrement","useRef","savedClear","interval","tick","current","useEffect","setInterval","undefined","clearInterval","useTimer","document","addEventListener","event","preventDefault","App","game","setGame","clickedIndex","type","newGame","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.264bf670.chunk.js","sourcesContent":["export enum CellState {\n  Unclicked,\n  Clicked,\n  Flagged,\n  Questioned,\n  UnclickedMine,\n  ClickedMine,\n  FlaggedMine,\n  QuestionedMine,\n  Invalid,\n}\n\nexport const nonMineStates = [CellState.Unclicked, CellState.Clicked, CellState.Flagged, CellState.Questioned];\nexport const mineStates = [\n  CellState.UnclickedMine,\n  CellState.ClickedMine,\n  CellState.FlaggedMine,\n  CellState.QuestionedMine,\n];\nexport const unclickedStates = [\n  CellState.Unclicked,\n  CellState.UnclickedMine,\n  CellState.Flagged,\n  CellState.FlaggedMine,\n  CellState.Questioned,\n  CellState.QuestionedMine,\n];\nexport const flaggedStates = [CellState.Flagged, CellState.FlaggedMine];\nexport const unclickedNonMineStates = [CellState.Unclicked, CellState.Flagged, CellState.Questioned];\nexport const clickedStates = [CellState.Clicked, CellState.ClickedMine];\n\nexport default class Cell {\n  private _isClicked: boolean = false;\n  private _isMine: boolean = false;\n  private _isFlagged: boolean = false;\n  private _isQuestioned: boolean = false;\n\n  public get cellState(): CellState {\n    if (this._isClicked) {\n      if (this._isMine) {\n        return CellState.ClickedMine;\n      } else {\n        return CellState.Clicked;\n      }\n    } else {\n      if (this._isMine) {\n        if (this._isFlagged) {\n          return CellState.FlaggedMine;\n        } else if (this._isQuestioned) {\n          return CellState.QuestionedMine;\n        } else {\n          return CellState.UnclickedMine;\n        }\n      } else {\n        if (this._isFlagged) {\n          return CellState.Flagged;\n        } else if (this._isQuestioned) {\n          return CellState.Questioned;\n        } else {\n          return CellState.Unclicked;\n        }\n      }\n    }\n  }\n\n  public click() {\n    if (this._isFlagged || this._isQuestioned) return;\n    this._isClicked = true;\n  }\n\n  public rightClick() {\n    if (this._isClicked) return;\n    if (this._isFlagged) {\n      this._isFlagged = false;\n      this._isQuestioned = true;\n    } else if (this._isQuestioned) {\n      this._isQuestioned = false;\n    } else {\n      this._isFlagged = true;\n    }\n  }\n\n  public set isMine(isMine: boolean) {\n    this._isMine = isMine;\n  }\n}\n","import \"./GameCell.css\";\nimport { CellState, unclickedStates } from \"../engine/Cell\";\n\ntype GameCellProps = {\n  cellState: CellState;\n  numNeighborMines: number;\n};\n\nfunction GameCell({ cellState, numNeighborMines }: GameCellProps) {\n  const getContent = (): string => {\n    if (cellState === CellState.Clicked) {\n      if (numNeighborMines > 0) {\n        return String(numNeighborMines);\n      }\n    }\n    if (cellState === CellState.ClickedMine) {\n      return \"ðŸ’£\";\n    }\n    if (cellState === CellState.Flagged || cellState === CellState.FlaggedMine) {\n      return \"ðŸš©\";\n    }\n    if (cellState === CellState.Questioned || cellState === CellState.QuestionedMine) {\n      return \"â“\";\n    }\n    return \"\";\n  };\n\n  const getClass = (): string => {\n    if (unclickedStates.includes(cellState)) {\n      return \"unclicked\";\n    } else if (cellState === CellState.Clicked) {\n      return \"clicked\";\n    } else if (cellState === CellState.ClickedMine) {\n      return \"clicked-mine\";\n    }\n\n    return \"\";\n  };\n\n  return <div className={`GameCell ${getClass()}`}>{getContent()}</div>;\n}\n\nexport default GameCell;\n","import \"./GameBoard.css\";\nimport Board, { CellIndex } from \"../engine/Board\";\nimport Cell from \"../engine/Cell\";\nimport GameCell from \"../GameCell/GameCell\";\n\ntype GameBoardProps = {\n  gameBoard: Board;\n  onCellClick: (e: React.MouseEvent<HTMLDivElement>, cellIndex: CellIndex) => void;\n};\n\nfunction GameBoard({ gameBoard, onCellClick }: GameBoardProps) {\n  return (\n    <div className=\"GameBoard\" id=\"game-board\" data-testid=\"game-board\">\n      {gameBoard.board.map((row: Cell[], rowNumber: number) => (\n        <div className=\"Row\" key={rowNumber}>\n          {row.map((cell: Cell, columnNumber: number) => (\n            <div\n              className=\"Cell\"\n              key={columnNumber}\n              onClick={(e: React.MouseEvent<HTMLDivElement>) =>\n                onCellClick(e, { row: rowNumber, column: columnNumber })\n              }\n              onContextMenu={(e: React.MouseEvent<HTMLDivElement>) =>\n                onCellClick(e, { row: rowNumber, column: columnNumber })\n              }\n            >\n              {\n                <GameCell\n                  cellState={gameBoard.getCellState({ row: rowNumber, column: columnNumber })}\n                  numNeighborMines={gameBoard.getCellNumNeighborMines({ row: rowNumber, column: columnNumber })}\n                />\n              }\n            </div>\n          ))}\n        </div>\n      ))}\n    </div>\n  );\n}\n\nexport default GameBoard;\n","export enum GameState {\n  Idle,\n  Active,\n  Won,\n  Lost,\n}\n","import Cell, { CellState, flaggedStates, mineStates, unclickedNonMineStates, unclickedStates } from \"./Cell\";\nimport { GameState } from \"./GameState\";\n\nconst neighborOffsets = [\n  { row: 0, column: 1 },\n  { row: 1, column: 0 },\n  { row: 0, column: -1 },\n  { row: -1, column: 0 },\n  { row: 1, column: 1 },\n  { row: -1, column: -1 },\n  { row: 1, column: -1 },\n  { row: -1, column: 1 },\n];\n\nexport type CellIndex = {\n  row: number;\n  column: number;\n};\n\nexport default class Board {\n  public rows: number;\n  public columns: number;\n  protected mines: number;\n  public mineCount: number; // used for mine display in UI\n  public board: Cell[][];\n\n  constructor(rows: number, columns: number, mines: number) {\n    this.validateInputs(rows, columns, mines);\n    this.rows = rows;\n    this.columns = columns;\n    this.mines = 0; // Initialize to 0 because we will increment as each mine is added\n    this.board = this.createInternalBoard(mines);\n    this.addMines(mines);\n    this.mineCount = this.mines;\n  }\n\n  /**\n   * Perform left click actions (click and click neighbors) on the\n   * cell at cellIndex and return the new GameState\n   * @param cellIndex the cell left clicked\n   * @returns the new GameState of the game after the action is complete\n   */\n  public click(cellIndex: CellIndex): GameState {\n    let cellState = this.getCellState(cellIndex);\n    if (cellState === CellState.Unclicked) {\n      this.floodfill(cellIndex);\n    } else if (cellState === CellState.UnclickedMine) {\n      this.explode();\n    } else if (this.isFullyFlaggedCell(cellIndex)) {\n      this.clickAllNeighbors(cellIndex);\n    }\n    this.mineCount = this.calculateMineCount();\n    const gameState = this.calculateGameState();\n    this.cleanUpGameIfNecessary(gameState);\n    return gameState;\n  }\n\n  /**\n   * Perform right click actions (flag, question, click neighbors) on the\n   * cell at cellIndex and return the new GameState\n   * @param cellIndex the cell right clicked\n   * @returns the new GameState of the game after the action is complete\n   */\n  public rightClick(cellIndex: CellIndex): GameState {\n    const cell = this.getCell(cellIndex);\n    if (unclickedStates.includes(cell.cellState)) {\n      cell.rightClick();\n    } else if (this.isFullyFlaggedCell(cellIndex)) {\n      this.clickAllNeighbors(cellIndex);\n    }\n    this.mineCount = this.calculateMineCount();\n    const gameState = this.calculateGameState();\n    this.cleanUpGameIfNecessary(gameState);\n    return gameState;\n  }\n\n  /**\n   * Calculate the current GameState of the board\n   */\n  protected calculateGameState(): GameState {\n    let stateCounts = this.getStateCounts();\n    if (!!stateCounts[CellState.ClickedMine]) {\n      return GameState.Lost;\n    } else if (\n      (stateCounts[CellState.Unclicked] || 0) +\n        (stateCounts[CellState.Flagged] || 0) +\n        (stateCounts[CellState.Questioned] || 0) ===\n      0\n    ) {\n      return GameState.Won;\n    }\n    return GameState.Active;\n  }\n\n  /**\n   * Calculate the mine count to display in the UI\n   * @returns A count of the total mines minus flagged cells\n   */\n  protected calculateMineCount(): number {\n    let count = this.mines;\n    for (let row = 0; row < this.rows; row++) {\n      for (let column = 0; column < this.columns; column++) {\n        if (flaggedStates.includes(this.getCellState({ row, column }))) {\n          count -= 1;\n        }\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get a map of counts of CellState for every cell on the board\n   */\n  protected getStateCounts(): { [key in CellState]?: number } {\n    let stateCounts: { [key in CellState]?: number } = {};\n    for (let row = 0; row < this.rows; row++) {\n      for (let column = 0; column < this.columns; column++) {\n        let cellState = this.getCellState({ row, column });\n        stateCounts[cellState] = (stateCounts[cellState] || 0) + 1;\n      }\n    }\n    return stateCounts;\n  }\n\n  /**\n   * Perform a left click on all neighbors of the cell at cellIndex\n   */\n  protected clickAllNeighbors(cellIndex: CellIndex) {\n    this.getInBoundNeighbors(cellIndex).forEach((neighbor) => {\n      if (this.getCellState(neighbor) === CellState.UnclickedMine) {\n        this.explode();\n      } else {\n        this.floodfill(neighbor);\n      }\n    });\n  }\n\n  /**\n   * Calculate the count of the number of adjacent mines in the 8 neighbors of the cell at board[row][column]\n   * @param row the row of the cell\n   * @param column the column of the cell\n   * @returns a count of neighbors containing mines\n   */\n  public getCellNumNeighborMines(cellIndex: CellIndex): number {\n    if (!this.isCellInBounds(cellIndex)) return 0;\n    return this.getInBoundNeighbors(cellIndex)\n      .map((neighbor) => this.isMineCell(neighbor))\n      .filter(Boolean).length;\n  }\n\n  /**\n   * Calculate the count of the number of adjacent flagged cells in the 8 neighbors of the cell at board[row][column]\n   * @param row the row of the cell\n   * @param column the column of the cell\n   * @returns a count of flagged neighbors\n   */\n  public getCellNumNeighborFlags(cellIndex: CellIndex): number {\n    if (!this.isCellInBounds(cellIndex)) return 0;\n    return this.getInBoundNeighbors(cellIndex)\n      .map((neighbor) => this.isFlaggedCell(neighbor))\n      .filter(Boolean).length;\n  }\n\n  /**\n   * Get the current Cell at board[row][column]\n   * @param row the row of the cell\n   * @param column the column of the cell\n   * @returns the Cell at board[row][column]\n   */\n  public getCell(cellIndex: CellIndex): Cell {\n    if (!this.isCellInBounds(cellIndex)) {\n      throw Error(\"Cell out of bounds\");\n    }\n    return this.board[cellIndex.row][cellIndex.column];\n  }\n\n  /**\n   * Get the current CellState for the cell at board[row][column]\n   * @param row the row of the cell\n   * @param column the column of the cell\n   * @returns the current CellState for the cell at board[row][column]\n   */\n  public getCellState(cellIndex: CellIndex): CellState {\n    if (!this.isCellInBounds(cellIndex)) {\n      throw Error(\"Cell out of bounds\");\n    }\n    return this.board[cellIndex.row][cellIndex.column].cellState;\n  }\n\n  /**\n   * Depth first search floodfill of open unclicked areas\n   */\n  protected floodfill(cellIndex: CellIndex) {\n    let cellState = this.getCellState(cellIndex);\n    if (cellState === CellState.Unclicked) {\n      this.getCell(cellIndex).click();\n      if (this.getCellNumNeighborMines(cellIndex) === 0) {\n        this.getInBoundNeighbors(cellIndex).forEach((neighbor) => {\n          this.floodfill(neighbor);\n        });\n      }\n    }\n  }\n\n  /**\n   * Mark all bombs as clicked\n   */\n  protected explode() {\n    for (let row = 0; row < this.rows; row++) {\n      for (let column = 0; column < this.columns; column++) {\n        if (this.isMineCell({ row, column })) {\n          this.board[row][column].click();\n        }\n      }\n    }\n  }\n\n  /**\n   * Get all neighbors of the cell at cellIndex that are in the board\n   */\n  protected getInBoundNeighbors(cellIndex: CellIndex): CellIndex[] {\n    let inBoundsNeighbors: CellIndex[] = [];\n    neighborOffsets.forEach((offset) => {\n      let neighbor: CellIndex = { row: cellIndex.row + offset.row, column: cellIndex.column + offset.column };\n      if (this.isCellInBounds(neighbor)) {\n        inBoundsNeighbors.push(neighbor);\n      }\n    });\n    return inBoundsNeighbors;\n  }\n\n  /**\n   * Return true if the cell at cellIndex is in board\n   */\n  protected isCellInBounds(cellIndex: CellIndex): boolean {\n    if (cellIndex.row < 0 || cellIndex.row >= this.rows) return false;\n    if (cellIndex.column < 0 || cellIndex.column >= this.columns) return false;\n    return true;\n  }\n\n  /**\n   * Instantiate the internal Board object for storing board state\n   */\n  protected createInternalBoard(mines: number): Cell[][] {\n    let board = Array(this.rows);\n    for (let row = 0; row < this.rows; row++) {\n      board[row] = Array(this.columns);\n      for (let column = 0; column < this.columns; column++) {\n        board[row][column] = new Cell();\n      }\n    }\n    return board;\n  }\n\n  /**\n   * Add numMines mines to the game board without exceeding the maximum\n   */\n  protected addMines(numMines: number) {\n    const maxMines = (this.rows * this.columns) / 2;\n    let addedMines = 0;\n    while (addedMines < numMines && this.mines < maxMines) {\n      let row = this.getRandomInt(this.rows);\n      let column = this.getRandomInt(this.columns);\n      if (this.isUnclickedNonMineCell({ row, column })) {\n        this.board[row][column].isMine = true;\n        addedMines++;\n        this.mines++;\n      }\n    }\n  }\n\n  protected isMineCell(cellIndex: CellIndex) {\n    return mineStates.includes(this.getCellState(cellIndex));\n  }\n\n  protected isUnclickedNonMineCell(cellIndex: CellIndex) {\n    return unclickedNonMineStates.includes(this.getCellState(cellIndex));\n  }\n\n  protected isFlaggedCell(cellIndex: CellIndex) {\n    return flaggedStates.includes(this.getCellState(cellIndex));\n  }\n\n  protected isFullyFlaggedCell(cellIndex: CellIndex) {\n    return (\n      this.getCellState(cellIndex) === CellState.Clicked &&\n      this.getCellNumNeighborFlags(cellIndex) === this.getCellNumNeighborMines(cellIndex)\n    );\n  }\n\n  /**\n   * Flags all mines at the end of a winning game\n   * @param gameState the current GameState\n   */\n  protected cleanUpGameIfNecessary(gameState: GameState) {\n    if (gameState === GameState.Won) {\n      for (let row = 0; row < this.rows; row++) {\n        for (let column = 0; column < this.columns; column++) {\n          if (this.getCellState({ row, column }) === CellState.QuestionedMine) {\n            this.rightClick({ row, column });\n          }\n          if (this.getCellState({ row, column }) === CellState.UnclickedMine) {\n            this.rightClick({ row, column });\n          }\n        }\n      }\n    }\n  }\n\n  protected validateInputs(rows: number, columns: number, mines: number): void {\n    const maxMines = (rows * columns) / 2;\n    if (mines < 0 || mines > maxMines) {\n      throw Error(`Please provide a number of mines between 0 and ${maxMines}`);\n    }\n    if (rows <= 0 || rows > 100) {\n      throw Error(\"Please provide a number of rows between 1 and 100\");\n    }\n    if (columns <= 0 || columns > 100) {\n      throw Error(\"Please provide a number of columns between 1 and 100\");\n    }\n  }\n\n  protected getRandomInt(max: number) {\n    return Math.floor(Math.random() * (max - 1));\n  }\n\n  public allCells(): Array<Cell> {\n    let arr: Array<Cell> = [];\n    for (let row = 0; row < this.rows; row++) {\n      arr = arr.concat(this.board[row]);\n    }\n    return arr;\n  }\n}\n","import _ from \"lodash\";\nimport Board, { CellIndex } from \"./Board\";\nimport { GameState } from \"./GameState\";\n\nexport default class Game {\n  public board: Board;\n  protected _gameState: GameState = GameState.Idle;\n\n  constructor(rows: number, columns: number, mines: number) {\n    this.board = new Board(rows, columns, mines);\n  }\n\n  get gameState(): GameState {\n    return this._gameState;\n  }\n\n  /**\n   * Perform left click actions (click and click neighbors) on the\n   * cell at cellIndex and return a deep copy of the game in its new state\n   * @param cellIndex the cell left clicked\n   * @returns a deep copy of the game in its new state\n   */\n  click(cellIndex: CellIndex): Game {\n    if (this._gameState === GameState.Won || this._gameState === GameState.Lost) {\n      return this;\n    }\n    this._gameState = this.board.click(cellIndex);\n    return _.cloneDeep(this);\n  }\n\n  /**\n   * Perform right click actions (flag, question and click neighbors) on the\n   * cell at cellIndex and return a deep copy of the game in its new state\n   * @param cellIndex the cell right clicked\n   * @returns a deep copy of the game in its new state\n   */\n  rightClick(cellIndex: CellIndex): Game {\n    if (this._gameState === GameState.Won || this._gameState === GameState.Lost) {\n      return this;\n    }\n    this._gameState = this.board.rightClick(cellIndex);\n    return _.cloneDeep(this);\n  }\n}\n","import \"./GameTimer.css\";\nimport { GameState } from \"../engine/GameState\";\nimport { useEffect, useRef, useState } from \"react\";\n\ntype GameTimerProps = {\n  gameState: GameState;\n};\n\n/**\n * An effect used to keep and update state for the game timer\n * @param increment callback to increment the timer\n * @param clear callback to reset the counter to zero\n * @param gameState the current GameState\n */\nfunction useTimer(increment: Function, clear: Function, gameState: GameState) {\n  const savedIncrement = useRef<Function>();\n  const savedClear = useRef<Function>();\n  let interval = useRef<NodeJS.Timer>();\n\n  function tick() {\n    savedIncrement.current && savedIncrement.current();\n  }\n\n  useEffect(() => {\n    savedIncrement.current = increment;\n    savedClear.current = clear;\n  });\n\n  useEffect(() => {\n    if (gameState === GameState.Active) {\n      interval.current = setInterval(tick, 1000);\n    } else if (\n      (gameState === GameState.Lost || gameState === GameState.Won || gameState === GameState.Idle) &&\n      interval.current !== undefined\n    ) {\n      clearInterval(interval.current);\n      if (gameState === GameState.Idle) {\n        savedClear.current && savedClear.current(0); // Going Idle implies the game was reset\n      }\n    }\n  }, [gameState]);\n}\n\nfunction GameCell({ gameState }: GameTimerProps) {\n  const [timer, setTimer] = useState(0);\n\n  useTimer(\n    () => setTimer(timer + 1),\n    () => setTimer(0),\n    gameState\n  );\n\n  return <div>{timer}</div>;\n}\n\nexport default GameCell;\n","import \"./App.css\";\nimport { CellIndex } from \"./engine/Board\";\nimport GameBoard from \"./GameBoard/GameBoard\";\nimport { useState } from \"react\";\nimport Game from \"./engine/Game\";\nimport GameTimer from \"./GameTimer/GameTimer\";\n\ndocument.addEventListener(\"contextmenu\", (event) => {\n  event.preventDefault();\n});\n\nfunction App() {\n  const rows = 20;\n  const columns = 20;\n  const mines = 50;\n\n  const [game, setGame] = useState(new Game(rows, columns, mines));\n\n  let onCellClick = (e: React.MouseEvent<HTMLDivElement>, clickedIndex: CellIndex) => {\n    if (e.type === \"click\") {\n      const newGame = game.click(clickedIndex);\n      setGame(newGame);\n    } else if (e.type === \"contextmenu\") {\n      const newGame = game.rightClick(clickedIndex);\n      setGame(newGame);\n    }\n  };\n\n  let reset = () => {\n    setGame(new Game(rows, columns, mines));\n  };\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <button onClick={reset}>Reset</button>\n        <div className=\"header-numbers\">\n          <GameTimer gameState={game.gameState} />\n          {game.board.mineCount}\n        </div>\n        <GameBoard gameBoard={game.board} onCellClick={onCellClick} />\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}